# 1. Shared_ptr
## 1.1 Compare 
- **Đối tượng trực tiếp (`spivision::MaskInfo MaskInfo;`)**:
    - Khi bạn khai báo `spivision::MaskInfo MaskInfo;`, bạn đang tạo một đối tượng trực tiếp của kiểu `spivision::MaskInfo`.
    - Đối tượng này được lưu trữ trên ngăn xếp (stack) nếu khai báo trong một hàm hoặc là thành viên của một lớp.
    - Khi ra khỏi phạm vi (scope) mà nó được khai báo, bộ nhớ của nó sẽ được tự động giải phóng.
    - Quản lý bộ nhớ đơn giản và không có chi phí thêm cho việc quản lý tham chiếu.
- **Con trỏ thông minh (`std::shared_ptr<spivision::MaskInfo> MaskInfo;`)**:
    - Khi bạn khai báo `std::shared_ptr<spivision::MaskInfo> MaskInfo {};`, bạn đang khai báo một con trỏ thông minh chia sẻ, nó có thể quản lý một đối tượng của kiểu `spivision::MaskInfo`.
    - Con trỏ này thường được cấp phát bộ nhớ trên heap.
    - `std::shared_ptr` sử dụng đếm tham chiếu để quản lý đối tượng. Điều này cho phép nhiều con trỏ thông minh chia sẻ quyền sở hữu đối với cùng một đối tượng.
    - Khi đếm tham chiếu về 0 (tức là không còn con trỏ thông minh nào tham chiếu đến đối tượng), bộ nhớ của đối tượng sẽ được giải phóng tự động.
    - Con trỏ thông minh mang lại sự an toàn về quản lý bộ nhớ và tránh rò rỉ bộ nhớ, nhưng có chi phí thêm do việc quản lý đếm tham chiếu.

Detai: 
- **uản lý bộ nhớ**:
    - Đối tượng trực tiếp: Quản lý thủ công, tự động hủy khi ra khỏi phạm vi.
    - Con trỏ thông minh: Tự động quản lý bộ nhớ, tránh rò rỉ bộ nhớ thông qua đếm tham chiếu.
- **Hiệu suất**:
    - Đối tượng trực tiếp: Hiệu suất cao hơn do không có chi phí quản lý đếm tham chiếu.
    - Con trỏ thông minh: Chi phí thêm do việc quản lý đếm tham chiếu.
- **Sử dụng**:
    - Đối tượng trực tiếp: Thích hợp khi không cần chia sẻ quyền sở hữu và đối tượng có vòng đời ngắn.
    - Con trỏ thông minh: Thích hợp khi cần chia sẻ quyền sở hữu và đối tượng có vòng đời phức tạp hoặc không xác định rõ ràng.

## 1.2 Example in DataHandler
+ Method in header file (.h)
```cpp
algorithmic->SetParam(context->m_Param.get());
```

+ When used in DataHandler
```cpp
// WITH: spivision::MaskInfo MaskInfo;
algorithmic->SetMaskInfo(&context->MaskInfo);

// WITH: std::shared_ptr MaskInfo {};
algorithmic->SetMaskInfo(context->MaskInfo.get());

```

Explain:
- **Nếu `context->m_Param` là một con trỏ thông minh (`std::shared_ptr` hoặc `std::unique_ptr`)**:
    - **Dùng `context->m_Param.get()`**:
```cpp
algorithmic->SetMaskInfo(context->MaskInfo.get());
```
    - `context->m_Param.get()` trả về con trỏ thô (raw pointer) đến đối tượng mà con trỏ thông minh quản lý. Điều này phù hợp nếu `SetParam` mong đợi một con trỏ thô.
- **Nếu `context->m_Param` là một đối tượng trực tiếp**:
    - **Dùng `&context->m_Param`**:
```cpp
algorithmic->SetMaskInfo(&context->MaskInfo);
```
    - `&context->m_Param` trả về địa chỉ của đối tượng trực tiếp, tạo thành một con trỏ thô đến đối tượng đó. Điều này phù hợp nếu `SetParam` mong đợi một con trỏ thô đến đối tượng.


```CSharp
System.Console.WriteLine("Hello");
```