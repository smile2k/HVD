
https://codelearn.io/sharing/su-dung-reflection-trong-csharp

## Định Nghĩa

Reflection là một tính năng mạnh mẽ trong .NET cho phép chương trình kiểm tra và tương tác với cấu trúc của chính nó hoặc của các đối tượng khác trong thời gian chạy. Nó nằm trong namespace `System.Reflection`.

## Tác Dụng và Ứng Dụng của Reflection
1. **Khám Phá Metadata**:
    
    - Reflection cho phép truy cập vào thông tin metadata của các kiểu (type), như các lớp (class), giao diện (interface), phương thức (method), thuộc tính (property), trường (field), sự kiện (event), và các tham số (parameter).
```CSharp
Type type = typeof(MyClass);
Console.WriteLine("Class Name: " + type.Name);

```

2. **Tạo và Khởi Tạo Đối Tượng Động**:
    
    - Reflection cho phép tạo các đối tượng mới trong thời gian chạy mà không cần biết trước tên lớp tại thời điểm biên dịch.
    
```CSharp
Type type = typeof(MyClass);
object instance = Activator.CreateInstance(type);
```
    
3. **Gọi Phương Thức Động**:
    
    - Reflection cho phép gọi các phương thức của đối tượng trong thời gian chạy, thậm chí các phương thức đó không được biết trước tại thời điểm biên dịch.
    
```CSharp
MethodInfo methodInfo = type.GetMethod("MyMethod");
methodInfo.Invoke(instance, new object[] { /* parameters */ });

```
4. **Truy Cập và Sửa Đổi Thuộc Tính và Trường**:
    
    - Reflection cho phép đọc và ghi giá trị của các thuộc tính và trường của một đối tượng.
    
```CSharp
PropertyInfo propertyInfo = type.GetProperty("MyProperty");
propertyInfo.SetValue(instance, "new value");
var value = propertyInfo.GetValue(instance);
```
5. **Khám Phá và Gán Attribute**:
    
    - Reflection có thể được sử dụng để khám phá các attribute được gán cho các lớp, phương thức, thuộc tính, và các thành phần khác.
    
   ```CSharp
var attributes = type.GetCustomAttributes(typeof(MyAttribute), true);
```
6. **Tạo Proxy và Nhúng Mã Động**:
    
    - Reflection.Emit cung cấp khả năng tạo các loại (type) mới và mã động trong thời gian chạy.
    
```CSharp
// Ví dụ đơn giản về tạo một phương thức động
AssemblyName assemblyName = new AssemblyName("DynamicAssembly");
AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule("DynamicModule");
TypeBuilder typeBuilder = moduleBuilder.DefineType("DynamicType", TypeAttributes.Public);
MethodBuilder methodBuilder = typeBuilder.DefineMethod("DynamicMethod", MethodAttributes.Public, typeof(void), Type.EmptyTypes);

ILGenerator ilGenerator = methodBuilder.GetILGenerator();
ilGenerator.EmitWriteLine("Hello from dynamic method!");
ilGenerator.Emit(OpCodes.Ret);

Type dynamicType = typeBuilder.CreateType();
object dynamicInstance = Activator.CreateInstance(dynamicType);
dynamicType.GetMethod("DynamicMethod").Invoke(dynamicInstance, null);
```
7. **Kiểm Tra và Khắc Phục Các Vấn Đề Trong Runtime**:
    
    - Reflection có thể được sử dụng để kiểm tra các vấn đề và thực hiện các hành động thích hợp dựa trên cấu trúc hiện tại của ứng dụng trong thời gian chạy.


## Example
```CSharp
using System;
using System.Reflection;

public class MyClass
{
    public void MyMethod()
    {
        Console.WriteLine("MyMethod called");
    }
}

public class Program
{
    public static void Main()
    {
        Type type = typeof(MyClass); // Lấy kiểu của 
        MyClass object instance = Activator.CreateInstance(type); // Tạo một đối tượng MyClass 
        MethodInfo methodInfo = type.GetMethod("MyMethod"); // Lấy thông tin phương thức MyMethod 
        methodInfo.Invoke(instance, null); // Gọi phương thức MyMethod trên đối tượng vừa tạo
    }
}
```

