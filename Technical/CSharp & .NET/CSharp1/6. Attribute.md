https://xuanthulab.net/su-dung-attribute-annotation-trong-lap-trinh-c-csharp.html
https://www.tutorialspoint.com/csharp/csharp_attributes.htm
# Concept
- Một thuộc tính chú thích (Annotation / Attribute) tác động vào một thành phần nào đó của chương trình (lớp, phương thức, thuộc tính) nó là một phần của `siêu dữ liệu` (metadata - loại dữ liệu cung cấp thêm thông tin về đối tượng nào đó). Annotation giúp thêm thông tin vào lớp, phương thức, thuộc tính những đoạn code mở rộng. Tính năng này trong Java gọi là Annotation, trong C# gọi là Attribute.
- Các thuộc tính chú thích có thể được truy xuất tra cứu ở thời điểm thực thi bằng kỹ thuật gọi là `reflection`, truy xuất ngược từ đối tượng biết được nguồn gốc mà đối tượng đó sinh ra (lớp).
- Trong C# có định nghĩa sẵn vô số các Attribute, để sử dụng nó bạn chỉ cần viết tên Attribute trong dấu `[]` trước đối tượng áp dụng như lớp, phương thức, thuộc tính lớp (có tham số như hàm, nếu Attribute đó yêu cầu).
```CSharp
[AttributeName(param1, param2 ...)]
```

## Predefined Attributes

The .Net Framework provides three pre-defined attributes −
- AttributeUsage
- Conditional
- Obsolete

## Some attributes
### 1. AttributeUsage
#### Mục Đích
`AttributeUsage` là một thuộc tính được sử dụng để xác định cách một thuộc tính tùy chỉnh có thể được áp dụng cho các thành phần của chương trình (ví dụ: lớp, phương thức, thuộc tính, v.v.).
#### Cách Sử Dụng
Bạn áp dụng `AttributeUsage` lên lớp định nghĩa thuộc tính tùy chỉnh của bạn để chỉ định các yếu tố sau:
- Các loại thành phần nào có thể được áp dụng thuộc tính này.
- Thuộc tính có thể được áp dụng nhiều lần cho cùng một thành phần không.
- Thuộc tính có thể được kế thừa bởi các lớp con không.
#### Ví dụ
```CSharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, 
                AllowMultiple = false, 
                Inherited = true)]
public class MyCustomAttribute : Attribute
{
    // Nội dung thuộc tính tùy chỉnh của bạn
}
```
Trong ví dụ này:

- `AttributeTargets.Class | AttributeTargets.Method`: Thuộc tính này có thể được áp dụng cho lớp và phương thức.
- `AllowMultiple = false`: Thuộc tính này chỉ có thể được áp dụng một lần cho mỗi lớp hoặc phương thức.
- `Inherited = true`: Thuộc tính này có thể được kế thừa bởi các lớp con.

### 2. Conditional
#### Mục Đích
`Conditional` là một thuộc tính cho phép bạn chỉ định rằng một phương thức sẽ chỉ được gọi nếu một điều kiện cụ thể được xác định. Điều kiện này thường là một biểu tượng (symbol) được xác định bằng `#define` trong mã nguồn hoặc qua các tùy chọn biên dịch.
#### Cách Sử Dụng
`Conditional` được áp dụng lên phương thức và dựa trên biểu tượng điều kiện. Nếu biểu tượng này không được xác định, lời gọi tới phương thức sẽ bị loại bỏ trong quá trình biên dịch.
#### Ví Dụ
```CSharp
#define DEBUG

using System;
using System.Diagnostics;

public class MyClass
{
    [Conditional("DEBUG")]
    public void DebugMethod()
    {
        Console.WriteLine("This method is called only in DEBUG mode.");
    }
}

public class Program
{
    public static void Main()
    {
        MyClass myClass = new MyClass();
        myClass.DebugMethod();
    }
}

```
Trong ví dụ này:

- `#define DEBUG`: Biểu tượng `DEBUG` được xác định.
- `DebugMethod` được đánh dấu với `Conditional("DEBUG")`, nên phương thức này sẽ chỉ được gọi nếu biểu tượng `DEBUG` được xác định.
### 3. Obsolete
Trong C# có thuộc tính `Obsolete`, để đánh dấu một phương thức, lớp ... nào đó là lạc hậu. Có nghĩa là thêm thông tin cho trình biên dịch biết một thành phần nào đó là đã lạc hậu, ví dụ:
Kết quả là khi soạn code, hay khi biên dịch sẽ có cảnh báo.
![[Pasted image 20240524111836.png]]

### 4. Required
Dữ liệu phải được thiết lập (!=null)
```CSharp
[Required (ErrorMessage="{0} cần thiết lập")]
```
### 5. StringLength 
Thiết lập độ dài trường dữ liệu
```CSharp
[StringLength (20,MinimumLength=3, ErrorMessage="Phải dài 3 đến 20 ký tự")]
```
### 6. Data Type
Chỉ ra dữ liệu phải liên kết phù hợp với một kiểu nào đó
```CSharp
[DataType(DataType.Text)]
[DataType(DataType.PhoneNumber)]
[DataType(DataType.EmailAddress)]
/.. Date, DateTime, Html, ImageUrl, MultilineText, Password, Time, Url
```
### 7. Range 
Chỉ ra dữ liệu phải nằm trong khoảng nào đó
```CSharp
[Range(18,99, ErrorMessage="Tuổi từ 18 đến 99")]
[Range(typeof(DateTime), "1/2/2004", "3/4/2004",
        ErrorMessage = "Value for {0} must be between {1} and {2}")]
```
### 8. Phone
Dữ liệu phải là số điện thoại
### 9. EmailAdress
Dữ liệu phải là dạng email
### 10. JsonIgnore / IgnoreMember
`JsonIgnore` là một thuộc tính từ thư viện Newtonsoft.Json (`Json.NET`) hoặc từ System.Text.Json (bắt đầu từ .NET Core 3.0 trở đi) được sử dụng để chỉ định rằng một thuộc tính hoặc trường không nên được tuần tự hóa thành JSON khi đối tượng được chuyển đổi thành chuỗi JSON.
```CSharp
using Newtonsoft.Json;

public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }

    [JsonIgnore]
    public int Age { get; set; }
}
```

```CSharp
Person person = new Person
{
    FirstName = "John",
    LastName = "Doe",
    Age = 30
};

string json = JsonConvert.SerializeObject(person);
// json: {"FirstName":"John","LastName":"Doe"}

```

# Example
## Custom Attribute Example
```Csharp
using System;
using System.Reflection;
using System.Runtime.InteropServices;

class Program
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property)]
    class DescribeAttribute : Attribute
    {
        public string DetailInfo { get; set; }
        public DescribeAttribute(string _DetailInfo)
        {
            DetailInfo = _DetailInfo;
        }
    }

    [Describe("Ten Class")]
    class User
    {
        public string Name { get; set; }
        [Describe(">0")]
        public int Age { get; set; }
        public string PhoneNumber { get; set; }

        public void PrintInfo() => Console.WriteLine(Name);
    }


    static void Main()
    {
        User user = new User() { Name = "HVD", Age = 25, PhoneNumber = "0123456789" };
        
        var properties = user.GetType().GetProperties();
        foreach (PropertyInfo property in properties)
        {
            foreach (var attr in property.GetCustomAttributes(false))
            {
                DescribeAttribute des= attr as DescribeAttribute;
                if (des != null)
                {
                    var value = property.GetValue(user);
                    Console.WriteLine("MDescribe: {0}, Value: {1}",des.DetailInfo, value);
                }
            }
        }
    }

    
}

```

## Some of attribute example

```CSharp
using System;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Runtime.InteropServices;

class Program
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property)]
    class DescribeAttribute : Attribute
    {
        public string DetailInfo { get; set; }
        public DescribeAttribute(string _DetailInfo)
        {
            DetailInfo = _DetailInfo;
        }
    }

    [Describe("Ten Class")]
    class User
    {
        [Required(ErrorMessage = "Name need created!")]
        [StringLength(50, MinimumLength = 3, ErrorMessage = "Name Length must from 3-100 character")]
        public string Name { get; set; } // Required value != null

        [Range(18, 80, ErrorMessage = "Age must be 18-80")]
        public int Age { get; set; }

        [Phone()]
        public string PhoneNumber { get; set; }

        [EmailAddress(ErrorMessage = "Email incorrect structure")]
        public string Email { get; set; }

        public void PrintInfo() => Console.WriteLine(Name);
    }


    static void Main()
    {
        User user = new User() { Name = "HV", Age = 25, PhoneNumber = "0123456789", Email = "abc@" };

        ValidationContext context = new ValidationContext(user);

        var result = new List<ValidationResult>();

        bool kg = Validator.TryValidateObject(user, context, result, true);
        if (kg == false)
        {
            result.ToList().ForEach(x =>
            {
                Console.WriteLine(x.ErrorMessage);
                Console.WriteLine(x.MemberNames.First());
            });
        }
    }

    
}
```